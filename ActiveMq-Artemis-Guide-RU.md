# ActiveMq Artemis

## Основные сведения
**ActiveMq Artemis** - это высокопроизводительный брокер сообщений, созданный для обработки большого объема сообщений в режиме реального времени. Artemis основан на JVM и поддерживает работу на платформах Windows, Linux и macOS.

Основные характеристики ActiveMq Artemis:
- Поддержка различных платформ - Windows, Linux и macOS;
- Поддержка различных протоколов - OpenWire, STOMP, AMQP, MQTT и HornetQ;
- Высокая производительность - брокер может обрабатывать до 10 миллионов сообщений в секунду;
- Масштабируемость - брокер может быть запущен в кластере и горизонтально масштабирован для обработки большого объема сообщений.

## Принцип работы ActiveMq Artemis

### Адрес
Одной из основных концепций в ActiveMQ Artemis является адрес. Адреса используются для идентификации точек назначения, куда могут отправляться и приходить сообщения. Каждый адрес представляет собой уникальную строку, которая состоит из двух частей: *имени адреса* и *типа маршрутизации (RoutingType)*. Имя адреса может содержать любую последовательность символов, а RoutingType определяет, каким образом будут обрабатываться сообщения, отправленные на этот адрес.

### RoutingType
В ActiveMQ Artemis есть два типа маршрутизации(RoutingType): **Anycast** и **Multicast**. Anycast означает, что сообщение будет доставлено только на одну очередь, даже если в адресе назначения указано несколько очередей. Multicast означает, что сообщение будет доставлено на все очереди, указанные в адресе. Таким образом, адрес может указывать на одну очередь (Anycast) или на несколько очередей (Multicast).

### Очереди
Очереди - это названия, используемые для идентификации конечных точек, где сообщения будут храниться и ожидать своей обработки. Очереди представляют собой FIFO-структуры данных и позволяют обрабатывать сообщения в порядке их поступления.

В ActiveMQ Artemis существует несколько типов очередей, включая *Persistent Queue* и *Non-Persistent Queue*. Persistent Queue сохраняет сообщения на диск до тех пор, пока они не будут доставлены или не истечет время их жизни; Non-Persistent Queue, в свою очередь, хранит сообщения в памяти, но при этом также удаляет сообщения только после того, как их доставка будет подтверждена или истечет время их жизни.

## Работа с Mq Artemis в C#
К сожалению, Apache не поставляет официальный клиент ActiveMq Artemis для .NET; 
однако, существует неофициальный пакет **ArtemisNetClient** от Havret для работы c ActiveMq Artemis в .NET, предоставляющая простой и интуитивно понятный интерфейс для создания, отправки и получения сообщений.

> Данный пункт руководства актуален для **ArtemisNetClient** версии **2.12.0**

Для начала работы с ArtemisNetClient, необходимо установить пакет с помощью *менеджера пакетов NuGet* или *dotnet CLI*. Для пакетного менеджера Вы можете использовать команду
```
Install-Package ArtemisNetClient
```
а для dotnet CLI
```
dotnet add package ArtemisNetClient
```

Далее, для использования ArtemisNetClient в своем проекте, вам необходимо добавить следующее пространство имен в свой проект:
```
using ActiveMQ.Artemis.Client;
```

Теперь Вы можете приступить к созданию фабрики для создания подключений к элементам Artemis, таким, как *ProducerClient* (для отправки сообщений) и *ConsumerClient* (для получения сообщений).

Для создания фабрики Вы можете использовать следующий код:
```
var endpoint = Endpoint.Create(
    "192.168.0.1", 
    61616, 
    "User", 
    "Password",
    Scheme.Amqp
);

var connection = await new ConnectionFactory().CreateAsync(endpoint);
```

### Отправка сообщений
Для отправки сообщений Вы должны создать экземпляр **IProducer** из **connection** объекта с помощью **CreateProducerAsync()** метода, как показано в следующем коде:
```
var producer = connection.CreateProducerAsync(address, RoutingType.Multicast);
```

Теперь Вы можете отправить сообщение с помощью следующего кода:
```
producer.SendAsync(new Message("foo"))
```

Обратите внимание, что при создании продусера мы задали параметр **RoutingType** равным **Multicast**, означающий, что сообщение будет отправлено во все доступные очереди сразу.

### Получение сообщений
Для получения сообщений Вы также должны создать экземпляр **IConsumer** из **connection** объекта с помощью **CreateConsumerAsync()** метода, как показано в следующем коде:
```
var consumer = connection.CreateConsumerAsync(address, queue);
```

Созданный нами объект consumer будет подписан на определенный адрес и очередь, откуда сможем получить сообщение c помощью **ReceiveAsync()** метода:
```
var message = await consumer.ReceiveAsync();
await consumer.AcceptAsync(message);
```

Обратите внимание, что в этом примере после получения сообщения мы подтверждаем его доставку с помощью **AcceptAsync()** метода, после чего полученное нами сообщение будет удалено из очереди.